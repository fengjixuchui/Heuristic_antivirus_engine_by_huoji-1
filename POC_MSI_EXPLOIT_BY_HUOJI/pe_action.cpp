#include "head.h"
#include "pe_action.h"
#include "virtual_helper.h"
/*
	解决掉api-ms-xxxxx
*/
typedef enum _WinVer
{
	WINVER_7 = 0x0610,
	WINVER_7_SP1 = 0x0611,
	WINVER_8 = 0x0620,
	WINVER_81 = 0x0630,
	WINVER_10 = 0x0A00,
	WINVER_10_RS1 = 0x0A01, // Anniversary update
	WINVER_10_RS2 = 0x0A02, // Creators update
	WINVER_10_RS3 = 0x0A03, // Fall creators update
	WINVER_10_RS4 = 0x0A04, // Spring creators update
	WINVER_10_RS5 = 0x0A05, // October 2018 update
	WINVER_10_19H1 = 0x0A06, // May 2019 update 19H1
	WINVER_10_19H2 = 0x0A07, // November 2019 update 19H2
	WINVER_10_20H1 = 0x0A08, // April 2020 update 20H1
} WinVer;

std::string get_dll_name_from_api_set_map(const std::string& api_set)
{
	std::wstring wapi_set(api_set.begin(), api_set.end());
	typedef LONG(__stdcall* fnRtlGetVersion)(PRTL_OSVERSIONINFOW lpVersionInformation);
	fnRtlGetVersion pRtlGetVersion = (fnRtlGetVersion)GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlGetVersion");
	RTL_OSVERSIONINFOEXW verInfo = { 0 };
	verInfo.dwOSVersionInfoSize = sizeof(verInfo);
	pRtlGetVersion((PRTL_OSVERSIONINFOW)&verInfo);
	ULONG ver_short = (verInfo.dwMajorVersion << 8) | (verInfo.dwMinorVersion << 4) | verInfo.wServicePackMajor;
	if (ver_short >= WINVER_10) {
		auto apiSetMap = (API_SET_NAMESPACE_ARRAY_10*)((X64PEB*)__readgsqword(0x60))->ApiSetMap;
		auto apiSetMapAsNumber = reinterpret_cast<ULONG_PTR>(apiSetMap);
		auto nsEntry = reinterpret_cast<PAPI_SET_NAMESPACE_ENTRY_10>((apiSetMap->Start + apiSetMapAsNumber));
		for (ULONG i = 0; i < apiSetMap->Count; i++) {
			UNICODE_STRING nameString, valueString;
			nameString.MaximumLength = static_cast<USHORT>(nsEntry->NameLength);
			nameString.Length = static_cast<USHORT>(nsEntry->NameLength);
			nameString.Buffer = reinterpret_cast<PWCHAR>(apiSetMapAsNumber + nsEntry->NameOffset);
			std::wstring name = std::wstring(nameString.Buffer, nameString.Length / sizeof(WCHAR)) + L".dll";
			if (_wcsicmp(wapi_set.c_str(), name.c_str()) == 0) {
				auto valueEntry = reinterpret_cast<PAPI_SET_VALUE_ENTRY_10>(apiSetMapAsNumber + nsEntry->ValueOffset);
				if (nsEntry->ValueCount == 0)
					return "";
				valueString.Buffer = reinterpret_cast<PWCHAR>(apiSetMapAsNumber + valueEntry->ValueOffset);
				valueString.MaximumLength = static_cast<USHORT>(valueEntry->ValueLength);
				valueString.Length = static_cast<USHORT>(valueEntry->ValueLength);
				auto value = std::wstring(valueString.Buffer, valueString.Length / sizeof(WCHAR));
				//note: there might be more than one value, but we will just return the first one..
				return std::string(value.begin(), value.end());
			}
			nsEntry++;
		}
	}
	else {
		__debugbreak();
	}
	return "";
}
class cFixImprot : public peconv::t_function_resolver {
public:
	std::map<std::string, uint64_t> _map;
	cFixImprot(std::map<std::string, uint64_t> context) {
		this->_map = context;
	}
	virtual FARPROC resolve_func(LPSTR lib_name, LPSTR func_name) {
		//printf("%s => %p \n", func_name, _map[std::string(func_name)]);
		return (FARPROC)_map[std::string(func_name)];
	}
};
class cListImportNames : public peconv::ImportThunksCallback
{
public:
	cListImportNames(BYTE* _modulePtr, size_t _moduleSize, std::vector<moudle_import>& name_to_addr)
		: ImportThunksCallback(_modulePtr, _moduleSize), nameToAddr(name_to_addr)
	{
	}

	virtual bool processThunks(LPSTR lib_name, ULONG_PTR origFirstThunkPtr, ULONG_PTR firstThunkPtr)
	{
		if (this->is64b) {
			IMAGE_THUNK_DATA64* desc = reinterpret_cast<IMAGE_THUNK_DATA64*>(origFirstThunkPtr);
			ULONGLONG* call_via = reinterpret_cast<ULONGLONG*>(firstThunkPtr);
			return processThunks_tpl<ULONGLONG, IMAGE_THUNK_DATA64>(lib_name, desc, call_via, IMAGE_ORDINAL_FLAG64);
		}
		IMAGE_THUNK_DATA32* desc = reinterpret_cast<IMAGE_THUNK_DATA32*>(origFirstThunkPtr);
		DWORD* call_via = reinterpret_cast<DWORD*>(firstThunkPtr);
		return processThunks_tpl<DWORD, IMAGE_THUNK_DATA32>(lib_name, desc, call_via, IMAGE_ORDINAL_FLAG32);
	}

protected:
	template <typename T_FIELD, typename T_IMAGE_THUNK_DATA>
	bool processThunks_tpl(LPSTR lib_name, T_IMAGE_THUNK_DATA* desc, T_FIELD* call_via, T_FIELD ordinal_flag)
	{
		DWORD call_via_rva = static_cast<DWORD>((ULONG_PTR)call_via - (ULONG_PTR)this->modulePtr);
		//std::cout << "via RVA: " << std::hex << call_via_rva << " : ";		
		LPSTR func_name = NULL;
		if ((desc->u1.Ordinal & ordinal_flag) == 0) {
			//名字解析
			PIMAGE_IMPORT_BY_NAME by_name = (PIMAGE_IMPORT_BY_NAME)((ULONGLONG)modulePtr + desc->u1.AddressOfData);
			func_name = reinterpret_cast<LPSTR>(by_name->Name);
			//std::cout << "name: " << func_name << " dll:" << lib_name << std::endl;
			std::string fuck_up_api_ms = lib_name;
			if (fuck_up_api_ms.find("api-ms-") != std::string::npos) {
				fuck_up_api_ms = get_dll_name_from_api_set_map(fuck_up_api_ms);
				if (fuck_up_api_ms.size() <= 1)
					__debugbreak();
			}
			moudle_import import_data = { 0 };
			memcpy(import_data.name, (char*)func_name, strlen(func_name));
			memcpy(import_data.dll_name, (char*)fuck_up_api_ms.c_str(), fuck_up_api_ms.size());
			import_data.function_address = call_via_rva;
			import_data.is_delayed_import = false;
			nameToAddr.push_back(import_data);
		}
		return true;
	}

	std::vector<moudle_import>& nameToAddr;
};
std::vector<moudle_export> pe_action::get_export(PVOID params_image_base) {
	std::vector<moudle_export> result;
	//导出表
	DWORD uExportSize = 0;

	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData((PVOID)params_image_base, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &uExportSize);

	if (pImageExportDirectory)
	{
		moudle_export export_data = { 0 };
		DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory->NumberOfNames);
		DWORD* pAddressOfFunction = (DWORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfFunctions);
		DWORD* pAddressOfNames = (DWORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfNames);
		WORD* pAddressOfNameOrdinals = (WORD*)((PUCHAR)params_image_base + pImageExportDirectory->AddressOfNameOrdinals);

		for (size_t i = 0; i < dwNumberOfNames; i++)
		{
			char* strFunction = (char*)((PUCHAR)params_image_base + pAddressOfNames[i]);
			//没有处理forward jmp export function
			DWORD functionRva = pAddressOfFunction[pAddressOfNameOrdinals[i]];
			//DWORD base = (DWORD)params_image_base + functionRva;
			moudle_export export_data = { 0 };
			memcpy(export_data.name, (char*)strFunction, strlen(strFunction));
			export_data.function_address = functionRva;
			result.push_back(export_data);
		}
	}
	return result;
}

/*
	作用: 映射一个可执行文件到虚拟机中
*/
int pe_action::load_pe(std::string parms_file_path, sim_process params_config)
{
	bool no_relocate = false;
	sim_process process = params_config;
	size_t size_of_pe;
	//peconv::process_relocation_table
	if (RtlImageDirectoryEntryToData == NULL)
		RtlImageDirectoryEntryToData = (RtlImageDirectoryEntryToDataFn)GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlImageDirectoryEntryToData");

	process.m_buffer = peconv::load_pe_module((const char*)parms_file_path.c_str(), size_of_pe, false, true);

	if (process.m_buffer == NULL)
		__debugbreak();

	if (peconv::relocate_module((BYTE*)process.m_buffer, size_of_pe, process.m_image_base) == false) {
		no_relocate = true;
	}
	std::vector<moudle_import> import_data_dict;
	std::vector<moudle_export> export_data_dict = get_export((PVOID)process.m_buffer);
	/*
		处理导入
	*/
	peconv::load_delayed_imports((BYTE*)process.m_buffer, (uint64_t)process.m_buffer);
	cListImportNames callback((BYTE*)process.m_buffer, size_of_pe, import_data_dict);
	peconv::process_import_table((BYTE*)process.m_buffer, size_of_pe, &callback);
	process.entry_point = (DWORD64)peconv::get_entry_point_rva((BYTE*)process.m_buffer);
	process.is_x64 = peconv::is64bit((BYTE*)process.m_buffer);
	process.m_nt_head = peconv::get_nt_hdrs64((BYTE*)process.m_buffer);
	process.m_nt_head32 = peconv::get_nt_hdrs32((BYTE*)process.m_buffer);
	if (no_relocate) {
		process.m_image_base = process.is_x64 ? (DWORD64)process.m_nt_head->OptionalHeader.ImageBase : (DWORD)process.m_nt_head32->OptionalHeader.ImageBase;
	}
	else {
		process.m_image_base = process.is_x64 ? (DWORD64)process.m_buffer : (DWORD)process.m_buffer;
	}
	process.process_data.moudle_list = push_to_virtual_helper(process.process_data.moudle_list, export_data_dict, import_data_dict, (char*)process.process_data.ImageFileName, (uint64_t)process.m_buffer, process.m_image_base, process.is_x64);
	printf("[PE]EntryPoint: %08X buff: %p image_base: %p process.entry_point: %p \n", process.m_image_base + process.entry_point, process.m_buffer, process.m_image_base, process.entry_point);

	//stack
	process.context.m_stack_base = process.is_x64 ? STACK_BASE_64 : STACK_BASE_32;
	process.context.m_stack_size = process.is_x64 ? STACK_SIZE_64 : STACK_SIZE_32;
	process.context.m_stack_end = process.context.m_stack_base + process.context.m_stack_size;
	//heap
	process.context.m_heap_base = process.is_x64 ? HEAP_ADDRESS_64 : HEAP_ADDRESS_32;
	process.context.m_heap_size = process.is_x64 ? HEAP_ADDRESS_64 : HEAP_SIZE_32;
	process.context.m_heap_end = process.context.m_heap_base + process.context.m_heap_size;
	if (g_global->hanlde_capstone == NULL)
		cs_open(CS_ARCH_X86, process.is_x64 ? CS_MODE_64 : CS_MODE_32, &g_global->hanlde_capstone);
	if (g_global->uc_engine == NULL)
		uc_open(UC_ARCH_X86, process.is_x64 ? UC_MODE_64 : UC_MODE_32, &g_global->uc_engine);
	/*
		映射全部导入dll到虚拟机中
	*/
	size_t size_of_map_pe;
	std::map<std::string, uint64_t> map_import_function;
	for (auto import_moudle : import_data_dict)
	{
		bool check = false;
		for (auto iter : process.process_data.moudle_list)
		{
			if (strcmp(iter.name, import_moudle.dll_name) == 0)
			{
				check = true;
				break;
			}
		}
		if (check)
		{
			continue;
		}
		printf("[PE][import] %s.%s address: %08X \n", import_moudle.dll_name, import_moudle.name, import_moudle.function_address);
		std::string tmp_cover = process.is_x64 ? "\\System32\\" : "\\SysWOW64\\";
		char windows_path[255];
		GetWindowsDirectoryA(windows_path, sizeof(windows_path));
		std::string moudle_path = std::string(windows_path) + tmp_cover + std::string(import_moudle.dll_name);
		DWORD64 moudle_base = (DWORD64)peconv::load_pe_module(moudle_path.c_str(), size_of_map_pe, false, false);
		DWORD moudle_base_32 = (DWORD)moudle_base;
		if (moudle_base == NULL)
			__debugbreak();
		if (peconv::relocate_module((BYTE*)moudle_base, size_of_map_pe, process.is_x64 ? moudle_base : moudle_base_32) == false) {
			__debugbreak();
		}
		std::vector<moudle_import> moudle_import_data_dict;
		std::vector<moudle_export> moudle_export_data_dict = get_export((PVOID)moudle_base);
		process.process_data.moudle_list = push_to_virtual_helper(process.process_data.moudle_list, moudle_export_data_dict, moudle_import_data_dict, (char*)import_moudle.dll_name, (uint64_t)moudle_base, moudle_base_32, process.is_x64);
		printf("[PE] moudle %s base %p moudle_base_32: %p \n", import_moudle.dll_name, moudle_base, moudle_base_32);
		/*
			映射到虚拟机里面
		*/
		uc_mem_map(g_global->uc_engine, process.is_x64 ? (uint64_t)moudle_base : moudle_base_32, size_of_map_pe, UC_PROT_READ | UC_PROT_EXEC);
		uc_mem_write(g_global->uc_engine, process.is_x64 ? (uint64_t)moudle_base : moudle_base_32, (void*)moudle_base, size_of_map_pe);
		for (auto iter : moudle_export_data_dict) {
			uint64_t function_address = NULL;
			if (process.is_x64)
				function_address = moudle_base + iter.function_address;
			else
				function_address = moudle_base_32 + iter.function_address;

			//printf("[PE][Export]%s.%s => %p \n", import_moudle.dll_name, iter.name, iter.function_address);
			map_import_function[std::string(iter.name)] = function_address;
		}
		//释放
		//peconv::free_pe_buffer((BYTE*)moudle_base);
	}

	printf("-------------------------------------------------------\n");
	//异常处理
	if (process.is_x64) {
		//64在exception table里面
		process.exception_table_base = (PIMAGE_RUNTIME_FUNCTION_ENTRY)RtlImageDirectoryEntryToData((PVOID)process.m_image_base, TRUE, IMAGE_DIRECTORY_ENTRY_EXCEPTION, (PULONG)&process.exception_table_size);
		printf("[PE] process.exception_table_base: %p process.exception_table_size %p \n", process.exception_table_base, process.exception_table_size);
		//__debugbreak();
	}
	else {
		;//32的异常处理
	}
	cFixImprot fix_imports_list(map_import_function);
	peconv::load_imports((BYTE*)process.m_buffer, &fix_imports_list);
	uc_err error_info = uc_mem_map(g_global->uc_engine, process.m_image_base, size_of_pe, UC_PROT_ALL);
	if (error_info != UC_ERR_OK) {
		__debugbreak();
	}
	uc_mem_write(g_global->uc_engine, process.m_image_base, (void*)process.m_buffer, size_of_pe);
	printf("[PE] Map PE Buff %p Base: %p Size: %p \n", process.m_buffer, process.m_image_base, size_of_pe);

	process = g_virtual->init_process_context(process);
	g_global->process.push_back(process);
	return g_global->process.size() - 1;
}
std::vector<struct_moudle> pe_action::push_to_virtual_helper(std::vector<struct_moudle> params_moudle_list, std::vector<moudle_export> params_export, std::vector<moudle_import> params_import, char* params_dll_name, uint64_t params_moudle_base, uint32_t x32base, bool is_x64)
{
	//检查dll是否已经在内存中
	struct_moudle moudle = { 0 };
	for (size_t i = 0; i < params_moudle_list.size(); i++)
	{
		if (params_moudle_list[i].base == params_moudle_base)
		{
			printf("[PE] skip %s \n", params_dll_name);
			return params_moudle_list;
		}
	}
	//解析头
	PIMAGE_DOS_HEADER m_dos_head = (PIMAGE_DOS_HEADER)params_moudle_base;
	PIMAGE_NT_HEADERS ntheader = (PIMAGE_NT_HEADERS)((LPBYTE)params_moudle_base + m_dos_head->e_lfanew);

	DWORD SectionAlignment;

	if (ntheader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		auto ntheader64 = (PIMAGE_NT_HEADERS64)ntheader;
		SectionAlignment = ntheader64->OptionalHeader.SectionAlignment;
	}
	else
	{
		SectionAlignment = ntheader->OptionalHeader.SectionAlignment;
	}
	auto SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)ntheader + sizeof(ntheader->Signature) + sizeof(ntheader->FileHeader) + ntheader->FileHeader.SizeOfOptionalHeader);

	for (WORD i = 0; i < ntheader->FileHeader.NumberOfSections; i++)
	{
		int prot = UC_PROT_READ;
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
			prot |= UC_PROT_EXEC;
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_WRITE)
			prot |= UC_PROT_WRITE;

		auto SectionSize = AlignSize(
			max(SectionHeader[i].Misc.VirtualSize, SectionHeader[i].SizeOfRawData),
			SectionAlignment);

		if (SectionHeader[i].Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
		{
			moudle_section section = { 0 };
			memcpy(section.name, (char*)SectionHeader[i].Name, 8);
			section.name[8] = 0;
			section.base = SectionHeader[i].VirtualAddress;
			section.size = SectionSize;
			section.protect_flag = prot;
			moudle.sections.emplace_back(section);
			printf("[PE]%s Section found: %s \n", params_dll_name, (char*)SectionHeader[i].Name);
		}
	}
	memcpy(moudle.name, (char*)params_dll_name, strlen(params_dll_name));
	moudle.base = is_x64 ? params_moudle_base : x32base;
	moudle.entry = ntheader->OptionalHeader.AddressOfEntryPoint;
	moudle.size = ntheader->OptionalHeader.SizeOfImage;
	for (size_t index = 0; index < params_export.size(); ++index)
	{
		moudle.export_function.push_back(params_export[index]);
	}
	for (size_t index = 0; index < params_import.size(); ++index)
	{
		moudle.import_function.push_back(params_import[index]);
	}
	params_moudle_list.push_back(moudle);
	return params_moudle_list;
}

