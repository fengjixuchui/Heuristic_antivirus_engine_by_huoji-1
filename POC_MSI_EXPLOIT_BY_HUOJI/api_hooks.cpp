#include "head.h"
#include "api_hooks.h"
namespace call_track {
	void print_string_hex(unsigned char* str, size_t len);
	void handle_code_run(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	void handle_memory_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void hanlde_unmap_mem(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void handle_memory_unmap_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void handle_syscall(uc_engine* uc ,void* user_data);
	extern bool find_code_speace(std::vector<struct_moudle> params_moudle_list, uint64_t params_rip, struct_moudle* out_info);
	extern bool print_export_function(struct_moudle params_moudle_list, sim_process* params_simprocess, uint64_t params_rip);
	uint64_t LastMoudleBase;
};

void call_track::print_string_hex(unsigned char* str, size_t len)
{
	unsigned char* c;
	for (c = str; c < str + len; c++) {
		printf("%02x ", *c & 0xff);
	}
	printf("\n");
}
void call_track::handle_memory_unmap_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	sim_process* data = (sim_process*)user_data;
	uint64_t currt_rax;
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &currt_rax);
	uint64_t currt_rbx;
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RBX : UC_X86_REG_EBX, &currt_rbx);
	printf("[handle_memory_unmap_read]excepting address: %p RAX: %p RBX: %p \n", address, currt_rax, currt_rbx);
	printf("Call Link \n");
	analysis::print_process_functions(data, false);
	uc_emu_stop(g_global->uc_engine);

}
void call_track::handle_syscall(uc_engine* uc, void* user_data)
{
	bool result = g_ssdt->hanlde_ssdt_function(uc);
	if (result == false) {
		uc_emu_stop(uc);
	}
}
void call_track::handle_memory_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t currt_rax;
	uint64_t currt_rip;
	sim_process* data = (sim_process*)user_data;
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &currt_rax);
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RIP : UC_X86_REG_EIP, &currt_rip);

	uint64_t read_address;
	auto read_error = uc_mem_read(g_global->uc_engine, address, &read_address, size);
	printf("[handle_memory_read]Handle address: %p size: %p rax: %p rip %p error: %d read_data: %p \n", address, size, currt_rax, currt_rip, read_error, read_address);

}
void call_track::hanlde_memory_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t currt_rax;
	uint64_t currt_rip;
	sim_process* data = (sim_process*)user_data;
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &currt_rax);
	uc_reg_read(uc, data->is_x64 ? UC_X86_REG_RIP : UC_X86_REG_EIP, &currt_rip);
	printf("[hanlde_memory_write]Handle address: %p(address) => %p(value) size: %p RAX: %p RIP %p \n", address, value ,size, currt_rax, currt_rip);

	uint64_t read;
	auto error = uc_mem_read(g_global->uc_engine, address, &read, size);
	printf("read : %d read: %p \n", error, read);
}
bool call_track::find_code_speace(std::vector<struct_moudle> params_moudle_list ,uint64_t params_rip, struct_moudle* out_info) {
	bool bFound = false;
	for (size_t i = 0; i < params_moudle_list.size(); i++)
	{
		if (params_rip >= params_moudle_list[i].base && params_rip <= params_moudle_list[i].base + params_moudle_list[i].size) {
			bFound = true;
			*out_info = params_moudle_list[i];
		}
	}
	return bFound;
}
bool call_track::print_export_function(struct_moudle params_moudle_list, sim_process* params_simprocess, uint64_t params_rip) {
	for (size_t i = 0; i < params_moudle_list.export_function.size(); i++)
	{
		if (params_rip == params_moudle_list.base + params_moudle_list.export_function[i].function_address) {
			printf("\033[32m\t ==> Function Name: %s \n\033[0m", params_moudle_list.export_function[i].name);
			break;
		}
		//printf("name: %s addreess:%p \n" ,params_moudle_list.export_function[i].name,  params_moudle_list.base  + params_moudle_list.export_function[i].function_address);
	}
	return false;
}
bool test = false;
void call_track::handle_code_run(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	sim_process* params_process = (sim_process*)user_data;
	uint64_t currt_rip = 0;
	uint64_t currt_rsp = 0;
	uint64_t currt_rax = 0;
	uc_reg_read(uc, params_process->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &currt_rax);
	uc_reg_read(uc, params_process->is_x64 ? UC_X86_REG_RIP : UC_X86_REG_EIP, &currt_rip);
	uc_reg_read(uc, params_process->is_x64 ? UC_X86_REG_RSP : UC_X86_REG_ESP, &currt_rsp);

	struct_moudle m_code_speace_info = { 0 };
	if (find_code_speace(params_process->process_data.moudle_list , address, &m_code_speace_info)) {
		if (LastMoudleBase != m_code_speace_info.base) {
			printf("\033[32m\t ==>[%s] Code Speace Switch to [%s] RIP: %p RSP: %p address: %p \n\033[0m", params_process->process_data.ImageFileName ,m_code_speace_info.name, address, currt_rsp, address);
			print_export_function(m_code_speace_info, params_process, address);
		}
	}
	else {
		printf("\033[31m\t ==> [%s] Unknwon RIP: %p address: %p \n\033[0m", params_process->process_data.ImageFileName, currt_rip, address);
		uc_emu_stop(uc);
	}

	LastMoudleBase = m_code_speace_info.base;
	cs_insn insn;
	memset(&insn, 0, sizeof(insn));
	unsigned char codeBuffer[15];
	uc_mem_read(uc, address, codeBuffer, size);
	print_string_hex(codeBuffer, strlen((const char*)codeBuffer));
	uint64_t virtualBase = address;
	uint8_t* code = codeBuffer;
	size_t codeSize = size;
	cs_disasm_iter(g_global->hanlde_capstone, (const uint8_t**)&code, &codeSize, &virtualBase, &insn);
	
	/*
		查看是否即将执行、读取我们的东西 这一段应该做成hashmap 但是...懒了 XD
	*/
	for (auto index : g_global->process) {
		for (auto moudle_iter : index.process_data.moudle_list) {
			for (auto export_iter : moudle_iter.export_function) {
				auto fun_rva_address = export_iter.function_address + moudle_iter.base;
				if (currt_rip == fun_rva_address) {					
					if (api_emu::api_simulation_router(uc, std::string(export_iter.name), m_code_speace_info.name, fun_rva_address,currt_rip, size, params_process)) {
						printf("\033[32m\t[!!!]handled call function [%s] function_address: %p size: %d \n\n\033[0m", export_iter.name, export_iter.function_address, size);
					}
					else {
						printf("\033[31m\t[!!!]unhandle call function [%s] function_address: %p size: %d \n\033[0m", export_iter.name, export_iter.function_address, size);
						uc_emu_stop(uc);
						analysis::print_process_functions(params_process, false);
						params_process->last_exception = STATUS_SUCCESS;
					}
					goto _found_call;
				}
			}
		}
	}
_found_call:
	if (params_process->last_exception != STATUS_SUCCESS)
		uc_emu_stop(uc);
	printf("[%s]0x%08X :\t\t%s\t%s\t rsp %p rax %p\n", m_code_speace_info.name, insn.address, insn.mnemonic, insn.op_str,currt_rsp,currt_rax);
	return;
}
