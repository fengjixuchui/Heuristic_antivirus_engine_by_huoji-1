#pragma once
#include "head.h"
#include "native_struct.h"
#define UNWIND_HISTORY_TABLE_NONE 0
#define UNWIND_HISTORY_TABLE_GLOBAL 1
#define UNWIND_HISTORY_TABLE_LOCAL 2
#define MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE 160

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define JMP_IND_OP 0xff
#define LEA_OP 0x8d
#define REP_PREFIX 0xf3
#define POP_OP 0x58
#define RET_OP 0xc3
#define RET_OP_2 0xc2
#define IS_REX_PREFIX(x) (((x) & 0xf0) == 0x40)
//
// Define unwind information flags.
//

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4
typedef union _UNWIND_CODE {
	struct {
		UCHAR CodeOffset;
		UCHAR UnwindOp : 4;
		UCHAR OpInfo : 4;
	};

	USHORT FrameOffset;
} UNWIND_CODE, * PUNWIND_CODE;
//
// Define unwind information structure.
//

typedef struct _UNWIND_INFO {
	UCHAR Version : 3;
	UCHAR Flags : 5;
	UCHAR SizeOfProlog;
	UCHAR CountOfCodes;
	UCHAR FrameRegister : 4;
	UCHAR FrameOffset : 4;
	UNWIND_CODE UnwindCode[1];

	//
	// The unwind codes are followed by an optional DWORD aligned field that
	// contains the exception handler address or a function table entry if
	// chained unwind information is specified. If an exception handler address
	// is specified, then it is followed by the language specified exception
	// handler data.
	//
	//  union {
	//      struct {
	//          ULONG ExceptionHandler;
	//          ULONG ExceptionData[];
	//      };
	//
	//      RUNTIME_FUNCTION function_address;
	//  };
	//

} UNWIND_INFO, * PUNWIND_INFO;

typedef struct _INVERTED_FUNCTION_TABLE_ENTRY {
	PRUNTIME_FUNCTION FunctionTable;
	PVOID ImageBase;
	ULONG SizeOfImage;
	ULONG SizeOfTable;
} INVERTED_FUNCTION_TABLE_ENTRY, * PINVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _INVERTED_FUNCTION_TABLE {
	ULONG CurrentSize;
	ULONG MaximumSize;
	BOOLEAN Overflow;
	INVERTED_FUNCTION_TABLE_ENTRY TableEntry[MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE];
} INVERTED_FUNCTION_TABLE, * PINVERTED_FUNCTION_TABLE;


class crt_buffer_t
{
public:
	crt_buffer_t();
	crt_buffer_t(size_t size);
	~crt_buffer_t();
	void* GetSpace(size_t needSize);
	size_t GetLength() { return m_cbSize; }
	void* GetBuffer() { return m_pBuffer; }

	void* m_pBuffer;
	size_t m_cbSize;
};

typedef enum _UNWIND_OP_CODES {
	UWOP_PUSH_NONVOL = 0,
	UWOP_ALLOC_LARGE,
	UWOP_ALLOC_SMALL,
	UWOP_SET_FPREG,
	UWOP_SAVE_NONVOL,
	UWOP_SAVE_NONVOL_FAR,
	UWOP_SPARE_CODE1,
	UWOP_SPARE_CODE2,
	UWOP_SAVE_XMM128,
	UWOP_SAVE_XMM128_FAR,
	UWOP_PUSH_MACHFRAME
} UNWIND_OP_CODES, * PUNWIND_OP_CODES;


class expect_handle
{
public:
	bool is_frame_in_bound(ULONG64 params_stack_frame, PULONG64 params_low_limit, PULONG64 params_high_limit);
	void copy_context(PCONTEXT params_destination_context, PCONTEXT params_source_context);
	void set_context(PCONTEXT params_context, sim_process params_process);
	void capture_context(PCONTEXT params_context, sim_process params_process);
	void get_stack_limit(PULONG64 params_low_limit, PULONG64 params_highlimit, sim_process params_process);
	PRUNTIME_FUNCTION convert_function_entry(IN PRUNTIME_FUNCTION params_function_address, IN ULONG64 params_image_base);
	PRUNTIME_FUNCTION lookup_runtime_function_table(ULONG64 params_exception_address,sim_process params_process);
	PUNWIND_INFO RtlpLookupPrimaryunwind_info(IN PRUNTIME_FUNCTION function_address, IN ULONG64 ImageBase, OUT PRUNTIME_FUNCTION* PrimaryEntry, sim_process params_process);
	PRUNTIME_FUNCTION FakeRtlpSameFunction(IN PRUNTIME_FUNCTION function_address, IN ULONG64 ImageBase, IN ULONG64 exception_address, sim_process params_process);
	PRUNTIME_FUNCTION unwind_prologue(IN ULONG64 ImageBase, IN ULONG64 exception_address, IN ULONG64 FrameBase, IN PRUNTIME_FUNCTION function_address, IN OUT PCONTEXT ContextRecord, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL, sim_process params_process);
	PEXCEPTION_ROUTINE virtual_unwind(IN ULONG HandlerType, IN ULONG64 ImageBase, IN ULONG64 exception_address, IN PRUNTIME_FUNCTION function_address, IN OUT PCONTEXT ContextRecord, OUT PVOID* HandlerData, OUT PULONG64 establisher_frame, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL, sim_process params_process);
	VOID FakeRtlpUnwindEx(IN PVOID TargetFrame OPTIONAL, IN PVOID TargetIp OPTIONAL, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL, IN PVOID ReturnValue, IN PCONTEXT OriginalContext, IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL, sim_process params_process);
	EXCEPTION_DISPOSITION C_specific_handler(sim_process params_process);
	EXCEPTION_DISPOSITION excute_exception_handler(_EXCEPTION_RECORD* ExceptionRecord, PVOID establisher_frame, _CONTEXT* ContextRecord, PDISPATCHER_CONTEXT DispatcherContext, sim_process params_process);
	bool dispatch_exception(PEXCEPTION_RECORD params_exception, PCONTEXT params_context, sim_process params_process);
	void process_exception(NTSTATUS params_last_exception, sim_process params_process);
};
extern expect_handle* g_except;