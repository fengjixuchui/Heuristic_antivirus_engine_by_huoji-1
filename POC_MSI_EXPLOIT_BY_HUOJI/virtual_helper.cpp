#include "head.h"
#include "virtual_helper.h"

/*
	virtual_helper: 设置底层系统虚拟化环境
*/
void init_descriptor64(SegmentDesctiptorX64* desc, uint64_t base, uint64_t limit, bool is_code, bool is_long_mode)
{
	desc->descriptor.all = 0;  //clear the descriptor
	desc->descriptor.fields.base_low = base;
	desc->descriptor.fields.base_mid = (base >> 16) & 0xff;
	desc->descriptor.fields.base_high = base >> 24;
	desc->base_upper32 = base >> 32;

	if (limit > 0xfffff) {
		limit >>= 12;
		desc->descriptor.fields.gran = 1;
	}

	desc->descriptor.fields.limit_low = limit & 0xffff;
	desc->descriptor.fields.limit_high = limit >> 16;

	desc->descriptor.fields.dpl = 0;
	desc->descriptor.fields.present = 1;
	desc->descriptor.fields.db = 1;   //64 bit
	desc->descriptor.fields.type = is_code ? 0xb : 3;
	desc->descriptor.fields.system = 1;  //code or data
	desc->descriptor.fields.l = is_long_mode ? 1 : 0;
}

sim_process virtual_helper::init_process_context(sim_process params_process)
{
	//设置底层环境
	init_virtual_processer();
	/*
		设置PEB
		代码没写完,以后再写设置进程PEB的东西
	*/
	params_process.context.peb.ImageBaseAddress = params_process.m_image_base;
	params_process.context.m_PebEnd = params_process.context.m_PebBase + AlignSize(sizeof(X64PEB), PAGE_SIZE);
	/*
		设置TEB
		代码没写完,以后再写设置进程TEB的东西
	*/
	params_process.context.m_TebEnd = params_process.context.m_TebBase + AlignSize(sizeof(X64TEB), PAGE_SIZE);
	uint64_t teb_alloc_size = AlignSize(sizeof(X64TEB), PAGE_SIZE);

	params_process.context.teb.ClientId.UniqueProcess = params_process.process_data.UniqueProcessId;
	params_process.context.teb.ClientId.UniqueThread = params_process.process_data.UniqueProcessId;
	params_process.context.teb.ProcessEnvironmentBlock = (X64PEB*)params_process.context.m_PebBase;

	params_process.context.teb.NtTib.StackBase = params_process.context.m_stack_base;
	params_process.context.teb.NtTib.StackLimit = params_process.context.m_stack_size;
	/*
		heap
	*/
	//params_process.context.peb.ProcessHeap = params_process.m_image_base - params_process.context.m_heap_base;
	params_process.context.peb.ProcessHeap = params_process.context.m_heap_base;
	/*
		设置GS
	*/
	params_process.context.gs_base.teb = params_process.context.m_TebBase;
	params_process.context.gs_base.peb = params_process.context.m_PebBase;
	uint64_t gs_alloc_size = AlignSize(sizeof(struct_gs_base), PAGE_SIZE);
	//__debugbreak();
	/*
		映射
	*/
	//peb
	uc_mem_map(g_global->uc_engine, params_process.context.m_PebBase, params_process.context.m_PebEnd - params_process.context.m_PebBase, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, params_process.context.m_PebBase, &params_process.context.peb, sizeof(X64PEB));
	//teb
	uc_mem_map(g_global->uc_engine, params_process.context.m_TebBase, params_process.context.m_TebEnd - params_process.context.m_TebBase, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, params_process.context.m_TebBase, &params_process.context.teb, sizeof(X64TEB));
	//gs
	uc_mem_map(g_global->uc_engine, params_process.context.m_gs_base, gs_alloc_size, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, params_process.context.m_gs_base, &params_process.context.gs_base, sizeof(struct_gs_base));
	/*
		//测试
		uint64_t read;
		auto error = uc_mem_read(g_global->uc_engine, g_global->gs_base, &read,0x8);
		printf("error: %d read: %08X \n", error, read);
	*/
	uc_x86_msr msr;
	msr.rid = (uint32_t)Msr::kIa32GsBase;
	msr.value = params_process.context.m_gs_base;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_MSR, &msr);
	return params_process;
}

void virtual_helper::init_virtual_processer() {
	//GDT R3的 R0暂时不做
	/*
	uc_x86_mmr gdtr;

	uint64_t kpcr_base = 0xfffff00000000000ull;

	KPCR kpcr;

	memset(&kpcr, 0, sizeof(KPCR));

	gdtr.base = kpcr_base + offsetof(KPCR, gdt);
	gdtr.limit = sizeof(kpcr.gdt) - 1;

	//code segment
	init_descriptor64(&kpcr.gdt[1], 0, 0xffffffffffffffff, true, true);
	//data segment
	init_descriptor64(&kpcr.gdt[2], 0, 0xffffffffffffffff, false, true);
	//one page data segment simulate gs
	//init_descriptor64(&kpcr.gdt[3], 0x7efdd000, 0xfff, false, true);
	 
	uc_mem_map(g_global->uc_engine, kpcr_base, PAGE_SIZE, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, kpcr_base, &kpcr, sizeof(KPCR));
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GDTR, &gdtr);
	*/
	
	SegmentSelector cs = { 0 };
	cs.fields.index = 1;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CS, &cs.all);

	SegmentSelector ds = { 0 };
	ds.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DS, &ds.all);

	SegmentSelector ss = { 0 };
	ss.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_SS, &ss.all);

	SegmentSelector es = { 0 };
	es.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_ES, &es.all);
		
	SegmentSelector gs = { 0 };
	gs.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GS, &gs.all);
	
	FlagRegister eflags = { 0 };
	eflags.fields.id = 1;
	eflags.fields.intf = 1;
	eflags.fields.reserved1 = 1;

	uc_reg_write(g_global->uc_engine, UC_X86_REG_EFLAGS, &eflags.all);

	uint64_t cr8 = 0;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CR8, &cr8);
	
	/*
		映射 m_KSharedUserDataBase
	*/
	uint64_t m_KSharedUserDataBase = 0x7FFE0000;
	uint64_t m_KSharedUserDataEnd = 0x7FFE0FFF; //0x7FFE2000
	uint64_t m_KSharedUserDataSize = AlignSize(m_KSharedUserDataEnd - m_KSharedUserDataBase, PAGE_SIZE);
	
	uc_mem_map(g_global->uc_engine, m_KSharedUserDataBase, m_KSharedUserDataSize, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_KSharedUserDataBase, (void*)m_KSharedUserDataBase, m_KSharedUserDataSize);
	//映射ssdt
	if (get_ssdt_function() == false) {
		__debugbreak();
		exit(1);
	}
}
void virtual_helper::clean_virtual(sim_process params_process) {
	peconv::free_pe_buffer((BYTE*)params_process.m_buffer);
	uc_close(g_global->uc_engine);
	cs_close(&g_global->hanlde_capstone);
}
void demon_thread(sim_process* params_process) {
	time_t start_time, end_time;
	start_time = time(NULL);  //!< 单位为s
	while (g_global->is_running)
	{
		end_time = time(NULL);
		if (difftime(end_time, start_time) > 30.f) {
			printf("[Demon] Stop Thread By timeout \n");
			uc_emu_stop(g_global->uc_engine);
			analysis::print_process_functions(params_process,0);
			break;
		}
		Sleep(10000);
	}
	CloseHandle(g_global->handle_deamon_thread);
	g_global->handle_deamon_thread = NULL;
}
void virtual_helper::create_daemon_thread(sim_process params_process) {
	DWORD threadId;
	g_global->is_running = true;
	g_global->handle_deamon_thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)demon_thread, (LPVOID)&params_process, 0, &threadId);
}
/*
	跑PE
*/
void virtual_helper::run(sim_process params_process) {
	
	//分配堆栈
	params_process.m_image_end = params_process.m_image_base + (params_process.is_x64 ? params_process.m_nt_head->OptionalHeader.SizeOfImage : params_process.m_nt_head32->OptionalHeader.SizeOfImage);
	//初始化stack
	
	uc_mem_map(g_global->uc_engine, params_process.context.m_stack_base, params_process.context.m_stack_size, UC_PROT_READ | UC_PROT_WRITE);
	//uc_mem_write(g_global->uc_engine, params_process.context.m_stack_base, params_process.context.stack_buf, params_process.context.m_stack_size);
	//初始化heap
	uc_mem_map(g_global->uc_engine, params_process.context.m_heap_base, params_process.context.m_heap_size, UC_PROT_READ | UC_PROT_WRITE);
	//uc_mem_map(g_global->uc_engine, params_process.m_image_base - params_process.context.m_heap_base, params_process.context.m_heap_size, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC);

	//写寄存器
	uint64_t Rsp = params_process.context.m_stack_end - 128;
	uc_reg_write(g_global->uc_engine, params_process.is_x64 ? UC_X86_REG_RSP : UC_X86_REG_ESP, &Rsp);
	uc_reg_write(g_global->uc_engine, params_process.is_x64 ? UC_X86_REG_RIP : UC_X86_REG_EIP, &params_process.context.m_stack_base);

	uc_mem_write(g_global->uc_engine, Rsp, &params_process.m_image_end, sizeof(params_process.m_image_end));
	//uc_mem_map(g_global->uc_engine, m_ImageEnd, 0x1000, UC_PROT_EXEC | UC_PROT_READ | UC_PROT_WRITE);
	
	//追踪代码
	uc_hook_add(g_global->uc_engine, &g_global->hook_code, UC_HOOK_CODE, call_track::handle_code_run, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem, UC_HOOK_MEM_READ | UC_HOOK_MEM_FETCH, call_track::handle_memory_read, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem_unmap, UC_HOOK_MEM_FETCH_UNMAPPED | UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED | UC_HOOK_MEM_FETCH_PROT, call_track::handle_memory_unmap_read, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem_write, UC_HOOK_MEM_WRITE | UC_HOOK_MEM_WRITE_PROT, call_track::hanlde_memory_write, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_sys_call, UC_HOOK_INTR | UC_HOOK_INSN, call_track::handle_syscall, &params_process, 1, 0, UC_X86_INS_SYSCALL);

	
	//映射模块到虚拟机里

	//单独映射kernelbase.dll
	//params_process = map_special_moudle(params_process, "kernelbase.dll");
	//params_process = map_special_moudle(params_process, "ntdll.dll");
	
	//写pe文件到虚拟机里
	//printf("[PE] Map PE Base: %p Size: %p \n", params_process.m_image_base, params_process.m_nt_head->OptionalHeader.SizeOfImage);
	/*
	for (auto index : params_process.process_data.moudle_list)
	{
		printf("[PE][moudle_list] %s address: %08X size:%08X \n", index.name, index.base, index.size);
		
		for (auto iter : index.export_function)
		{
			uc_mem_write(g_global->uc_engine, index.base + iter.function_address, params_process.is_x64 ? "\xC3\x00\x00" 
																										: "\xC2\x04\x00", 4);
		}
	}*/
	
	printf("[virtual_helper]EntryPoint: %p \n", params_process.m_image_base + params_process.entry_point);
	create_daemon_thread(params_process);
	uc_err uc_engine_error_code = UC_ERR_OK;
	params_process.run_rip = params_process.m_image_base + params_process.entry_point;
	params_process.last_exception = STATUS_SUCCESS;
	while (true)
	{
		uc_emu_start(g_global->uc_engine, params_process.run_rip, params_process.m_image_end, 0, 0);
		if (params_process.last_exception != STATUS_SUCCESS)
		{
			auto except = params_process.last_exception;
			params_process.last_exception = STATUS_SUCCESS;
			g_except->process_exception(except, params_process);
		}
		else
		{
			break;
		}
	}
	
	g_global->is_running = false;
	printf("[virtual_helper]error : %d ", uc_engine_error_code);
	
	//uint64_t read = 0x13337;
	//auto error = uc_mem_write(g_global->uc_engine, 0x8, &read, 0x4);
	//printf("read stack error: %d read: %p \n", error, read);
}
